# CLR基础
虽然\.NET Framework已经逐渐淘汰了，转而被\.Net Core 替代，而\.Net Core使用的是CoreCLR，但CLR与CoreCLR有很多相似的地方，并且CLR有《CLR Via C#》讲解，所以先了解CLR再学习CoreCLR会方便很多。

## 1 CLR执行模型
CLR（Common Language Runtime， 公共语言运行时）是  .NET Framework  框架的核心组件，它为 .NET 应用程序提供了一个运行时环境。CLR 扮演了虚拟机的角色，主要负责内存管理、程序集加载、安全性、异常处理和线程同步等功能。

CLR 是 .NET 平台独有的，而不是 C# 独有的。它是为整个 .NET 生态系统设计的运行时环境，不局限于任何特定语言。CLR 支持多种 .NET 语言，包括：
- C#
- VB\.NET
- F#
- 其他 .NET 兼容语言

**CLR主要组成部分：**

![2024-12-13-05-06-37.png](./images/2024-12-13-05-06-37.png)

- `CTS`：定义了所有 .NET 支持的类型和规则，提供了一个完整的类型系统。也就是定义了我们设计的编程语言可以做什么，不可以做什么，具有哪些特征。
- `BCL`：集成具有支持\.NET Framework 类库运行时的代码
- `Thread Support`：提供了多线程编程的类和接口
- `COM`：处理与COM之间的配置
- `Type Checker`：检查并禁止非安全的类型转换以及未初始化的变量的使用
- `Exception Manager`:提供结构化的异常处理，与Windows结构化异常处理机制（SHE）集成，改进了错误报告
- `Security Engine`:提供基于认证的安全机制
- `Debugger`:使开发者能调试和跟踪应用程序代码
- `JIT`：负责将IL翻译成本机执行代码 (CPU指令)
- `Code Manager`：管理代码的执行
- `Garbage Collection`：负责整个.NET运行时托管代码的内存分配与释放任务，它通过一定的优化算法选择收集对象和时间，并进行自动的垃圾收集
- `Class Loader`：将应用程序的汇编加载到内存中。汇编包括IL、描述应用程序中组件的元数据（类和类的布局描述），以及其他应用程序所需的组件


**CLR工作原理：**

![2024-12-13-05-46-17.png](./images/2024-12-13-05-46-17.png)

### 1.1 将源代码编译成托管模块

运行时CLR不关心开发人员用的哪一种语言写代码，意味着我们可以选择任何一种编程语言，只要编译器是面向CLR的。事实上，编译器可以视为是语法检查器和“正确代码”分析器。编译器检测源代码并根据我们的意图（我们自己写的代码）输出描述代码（中间代码/目标代码 等等）。编译过程中，无论选择哪个编译器，结果都是托管模块。

![2024-11-13-03-35-49.png](./images/2024-11-13-03-35-49.png)

面向CLR的编译器除了生成IL，还在每个托管模块中生成完整的元数据（一个数据表集合，描述模块中定义了什么，引用了什么）。

### 1.2 将托管模块合并成程序集

<hr>
<div style="color:grey">
托管模块与程序集概念理解：
一个开发团队有多个成员与一个负责人，外部人员只需要知道负责人即可，负责人知道团队内部一切情况。这时候：
团队 = 程序集、
负责人 = 托管主模块、
成员 = 普通托管模块
</div>
<hr>

托管模块组成部分（以文件结构区分）：

![2024-12-09-08-20-28.png](./images/2024-12-09-08-20-28.png)

![2024-12-09-08-34-17.png](./images/2024-12-09-08-34-17.png)

### 1.3 加载公共语言运行时
生成的每个程序集可以是可执行应用程序，也可以是DLL。

由CLR管理程序集中的代码的执行，所以目标机器必须安装好\.NET Framework。一些版本的Windows在发售的时候就已经打包好了\.NET Framework。


![2024-11-18-21-03-51.png](./images/2024-11-18-21-03-51.png)

如果程序集文件值包含类型安全的托管代码，代码在32位和64位Windows上都能正常工作，源代码无需任何改动。

Microsoft发布SDK命令行实用程序DumpBin.exe和CorFlags.exe，可用它们检查编译器生成的托管模块所嵌入的信息。

**CLR具体加载步骤：**

- Windows检查文件头
    - 判断需要32位还是64位空间
    - 检查嵌入的CPU架构信息，确保当前计算机CPU符合要求
- Windows的64位版本通过WoW64（Windows on Windows64）技术运行32位windows应用程序
- windows检查EXE文件头
    - 决定是32位还是64位进程后，会在检查地址空间加载MSCorEE.dll的x86，x64或ARM版本
        - x86/ARM版本：MSCorEE.dll的x86版本在`%SystemRoot%\System32`目录中
        - x64版本：MSCorEE.dll的x86版本在`%SystemRoot%\SysWow64`目录中，64位版本则在`%SystemRoot%\System32`目录中（为了向后兼容）
- 进程主线程调用MSCorEE.dll中定义的一个方法
    - 初始化CLR
    - 加载EXE程序集
    - 调用入口Main方法
- 托管应用程序启动并运行    

### 1.4 执行程序集的代码
托管程序集同时包含元数据和IL。

IL是与CPU无关的机器语言，能访问和操作对象类型，提供指令创建和初始化对象，调用对象上的虚方法以及直接操作数组元素。提供了抛出和捕捉异常指令实现错误处理。可将IL视为一种面向对象的机器语言。

高级语言通常只公开CLR全部功能的一个子集，而IL汇编语言允许开发人员访问CLR全部功能。（如果语言A隐藏我们需要的一个CLR功能，那么我们可以使用IL或提供了所需功能的语言B来写那部分代码，反正最后都转化为IL汇编语言）。`混合语言编程`是一个值得考虑的选择。

JIT 编译是在程序执行时（而不是编译时）将中间语言（IL）编译为机器指令。它是在程序和用户交互过程中动态完成的。

一个方法首次调用：
- CLR检测出Main的代码引用的所有类型
    - 导致CLR分配一个内部结构管理对引用类型的访问
- Main方法引用一个Console类型
    - 导致CLR分配一个内部结构，在这个内部结构中，Console类型定义的每个方法都有一个对应的记录项
    - 每个记录项都含有一个地址，根据地址找到方法实现
    - 初始化时，CLR将每个记录项都指向包含在CLR内部的一个未编档函数JITCompiler（负责将方法的IL代码编译成本机CPU指令）
- Main首次调用WriteLine，调用JITCompiler
    - JITCompiler被调用时知道要调用的是哪个方法，以及具体是什么类型定义该方法
    - JITCompiler在该类型的程序集元数据中查找被调用方法的IL
    - JITCompiler验证IL代码，并翻译成本机CPU指令
    - 本机CPU指令保存到动态分配的内存块
    - JITCompiler回到CLR为类型创建的内部数据结构，找到与被调用方法对应的记录，修改最初对JITCompiler的引用，使其指向内存块地址
    - JITCompiler跳转到内存块中代码，这些代码是WriteLine(string)方法具体实现 
    - 执行完代码后回到Main

![2024-12-12-09-35-04.png](./images/2024-12-12-09-35-04.png)

一个方法第二次调用：
- Main第二次调用WwriteLine
    - 直接执行内存块中的代码
    - 执行后再次回到Main

![2024-12-13-01-28-30.png](./images/2024-12-13-01-28-30.png)

#### 1.4.1 IL与验证
IL特点：
- IL基于栈
- IL没有提供操作寄存器的指令
- IL指令是无类型（typeless）的
    - IL 指令本身不明确指示变量的具体类型（int,string,...）
        - <p style="color:grey">IL 只关心数据的“形态”—，例如，IL 会将 int 视作一个特定大小的“数据单元”，但它不会明确地使用 int 这个类型名称，而是用一个更通用的指令（如 ldc.i4）来表示加载一个整数</p>
    - IL 不直接包含类型信息，但它的元数据（metadata）中包含了类型的具体定义。元数据中会描述类、方法、字段、参数等的具体类型，JIT 编译器会根据这些元数据来处理类型信息并生成相应的机器代码。

将IL编译成本机CPU指令时，CLR执行**验证**过程：检查高级IL代码，确保代码所做的一切是安全的。

Windows每个进程都有自己的虚拟空间
#### 1.4.2 不安全代码


### 1.5 本机代码生成器：NGen.exe

### 1.6 Framework类库

### 1.7 通用类型系统


### 1.8 公共语言规范

![2024-12-13-09-15-48.png](./images/2024-12-13-09-15-48.png)

### 1.9 与非托管代码的互操作性




## 2 生成、打包、部署和管理应用类型及程序

## 3 共享程序集合强命名程序
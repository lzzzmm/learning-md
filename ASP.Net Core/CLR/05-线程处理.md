# 线程处理
## 26 线程基础
### 26.1 Window为什么要支持线程
在早期的操作系统中，整个系统只有一个执行线程，操作系统代码和应用程序代码共用这个线程，导致长时间运行的任务（如打印）会阻塞系统，造成整个机器冻结。

微软意识到16位Windows不足以满足现代需求，决定设计一个新的操作系统内核——Windows NT。新内核采用多进程架构，每个进程拥有独立的虚拟地址空间，防止进程间互相干扰和访问操作系统内核。

不过，单个CPU执行死循环仍会导致系统某些部分冻结。为此，微软引入了线程的概念，虚拟化CPU资源，使每个进程拥有自己的线程。这样，即使某个进程死循环“冻结”，其他进程的线程仍能运行。

**总的来说：进程虚拟化的是“空间”（内存和资源），线程虚拟化的是“时间”和“执行”能力（CPU调度）。**

### 26.2 线程开销
以下讨论基于早起单CPU计算机。

线程不仅是CPU执行的基本单位，还需要占用一定的内存资源，包括内核对象、线程环境块、用户栈和内核栈等：
- 线程内核对象
  - 每个线程对应一个内核对象，保存一组对线程进行描述的线程的属性和包含线性上下文（包含CPU寄存器集合的内存块）
- 线程环境块 TEB
  - 位于用户模式，占用一个内存页（4KB），包含线程异常处理链、线程本地存储（TLS）以及图形接口（GDI/OpenGL）使用的数据结构
- 用户模式栈
  - 用于存储函数调用的局部变量、参数和返回地址（指出当前方法返回时，线程应该从什么地方接着执行）。Windows默认保留1MB地址空间，实际物理内存按需分配。
- 内核模式栈
  - 用于线程执行内核代码时存储参数、局部变量和返回地址。
- DLL 线程连接(attach)和线程分离(detach)通知
  - 创建或销毁线程时，Windows会通知所有非托管DLL，让它们执行线程初始化或清理操作

现在随便一个进程可能加载几百个DLL。意味着新建一个进程和销毁一个进行都会调用着几百个DLL函数。严重影响性能。


单CPU一次只能执行一个线程，Windows通过时间片（quantum）让多个线程轮流使用CPU。时间片结束，就会发生上下文切换。上下文切换步骤：
  - 保存当前线程的寄存器状态到该线程的内核对象中的上下文结构
  - 选择下一个要运行的线程，如果它属于另一个进程，还需要切换CPU所使用的虚拟地址空间
  - 恢复新线程的寄存器状态，让CPU从新线程的执行点继续运行


Windows 大约每 30 毫秒执行一次上下文切换。上下文切换是净开销。

执行一个线程时，线程的代码和数据在CPU高速缓存（cache）中，使CPU不必经常访问RAM（速度比cache慢很多），当Window切换到新线程时，新线程访问的是不同数据，所以需要访问RAM来填充它的高速缓存，但是在30毫秒后一次新的上下文切换又发生了。

**一个时间片结束，Window决定再次调用同一线程，那么就不会执行上下文切换。**

**要创建高性能应用程序和组件，应该尽量避免上下文切换。**

执行垃圾回收时，CLR必须挂起所有线程，遍历它们的栈查找根以便对堆中的对象进行标记，再次遍历栈更新根，再恢复所有线程。**所以减少线程的数量也会显著提升垃圾回收器的性能。**

**根据上述讨论，结论是必须尽量避免使用线程，因为它们要耗用大量内存，而且需要相当多的时间来创建、销毁和管理。Windows 在线程之间记性上下文切换，以及在发生垃圾回收的时候，也会浪费不少时间。**


线程好处：
- 如果某个应用程序的线程陷入死循环，Windows 会抢占它，把 CPU 分配给其他线程。这样，“任务管理器”的线程就能运行，用户可以用它终止出问题的进程。被终止的进程会结束，相关数据丢失，但其他进程不会受影响，系统也无需重启


**根据上述讨论，我们还得出了另一个结论，那就是有时必须使用线程，因为它们使 Windows 变得更健壮，响应更灵敏**(就是说线程是必要的，但应该在需要的地方用、并且数量要合理控制)

安装了多个 CPU(或者一个多核 CPU)的计算机可以真正同时运行几个线程，这提升了应用程序的可伸缩性(用更少的时间做更多的工作)。Windows 为每个 CPU 内核都分配一个线程，每个内核都自己执行到其他线程的上下文切换。Windows 确保单个线程不会同时在多个内核上调度，因为这会带来巨大的混乱。

### 26.3 停止疯狂
![2025-08-10-14-42-25.png](./images/2025-08-10-14-42-25.png)

机器正在运行 251 个进程，有3913个线程。看 CPU 利用率读数：它显示我的 CPU “忙” 的时间是 2%，这意味着在 98% 的时间里，这 3913 个线程什么事情都没做————它们白白霸占着内存。线程未运行时，这些内存是不会使用的。

这些应用程序不需要这些在 98% 的时间里什么事情都不做的线程。

![2025-08-10-14-45-22.png](./images/2025-08-10-14-45-22.png)

System 创建了 316 个线程，CPU 利用率却为 0%，在 Windows 中，进程是十分 ”昂贵“ 的。创建一个进程通常要花几秒钟的时间，必须分配大量内存，这些内存必须初始化， EXE 和 DLL 文件必须从磁盘上加载，等等。所以，开发人员决定停止创建进程，改为创建线程。这正是我们看到有这么多线程的原因。但是，虽然线程比进程廉价，它们和其他系统资源相比仍然十分昂贵，所以还是应该省着用，而且要用得恰当。

可以肯定地说，上面的所有这些应用程序都在以效率低下的方式使用线程。所有这些线程在系统中都没有存在的必要。在应用程序中分配资源是十分正常的一件事件，但分配了又不用纯属浪费！另外，为线程栈分配这么多内存，意味着一些更重要的数据(比如用户的文档)获得的内存变少了。

### 26.4 CPU 发展趋势
CPU 厂商过去只知道一味地提高 CPU 速度，但高速运行的CPU 会产生大量热量，用不了多久，CPU 和主板便会烧坏。

今天的计算机使用了以下三种 CPU 技术：
- 多个CPU（多路处理器）
  - 主板上有多个CPU插座，每个插入一个独立CPU
  - 体积大、成本高、功耗高，因此普通用户中不常见
- 超线程
  - Intel专利技术，一个物理CPU在操作系统中表现为两个逻辑CPU
  - 有两套架构状态（寄存器等），但共用一套执行单元，当一个线程因缓存未命中、分支预测错误或数据依赖而停顿时，硬件自动切换执行另一个线程。
  - 对操作系统透明，看似两个线程并发运行，实际共享执行资源
- 多核CPU
  - 一个芯片上集成多个独立的处理核心，每个核心能真正并行执行线程
  - 多核可与超线程结合，进一步提升并发性能

### 26.6 使用专用线程执行异步的计算限制操作
以下内容将讨论Thread显示创建线程执行计算限制操作。当然大多数创建下建议用线程池，只有在极少数需要特殊线程行为时（前台、长时间运行、特殊优先级、需强制终止）才显示使用Thread来创建专用线程。

![2025-08-16-19-35-30.png](./images/2025-08-16-19-35-30.png)

构造 Thread 对象是轻量级的操作，因为它并不实际创建一个操作系统线程。要实际创建操作系统线程，并让它开始执行回调方法，必须调用 Thread 的 Start 方法，向它传递要作为回调方法的实参传递的对象(状态)。

### 26.8 线程调度和优先级
抢占式操作系统必须使用算法判断在什么时候调度哪些线程多长时间。

- 每个线程的内核对象都包含一个上下文结构。上下文(context)结构反映了线程上一次执行完毕后 CPU 寄存器的状态
- 一个时间片之后， Windows 检查现在的所有线程内核对象
- 这些对象中，只有哪些没有正在等待什么的线程才适合调度。Windows 选择一个可调度的线程内核对象，并上下文切换到它，只有哪些没有正在等待什么的线程才适合调度
- 然后，线程开始执行代码，并在其进程的地址空间处理数据
- 过了一个时间片之后， Windows 执行下一次上下文切换。 Windows 从系统启动开始便一直执行上下文切换，直到系统关闭为止

Windows 之所以被称为抢占式多线程操作系统，是因为线程可在任何时间停止(被抢占)并调度另一个线程。

不能保证自己的线程一直运行，你阻止不了其他线程的运行。

<hr>

- 怎样保证线程在发生某个事件后的一段时间内开始运行?
- 怎样保证一个线程在网络有数据传来的 1 毫秒内开始运行?


实时操作系统能做出这样的保证，但 Windows 不是实时操作系统。

实时操作系统（RTOS）是一类操作系统，它最重要的目标不是“速度快”，而是 保证任务在严格的时间限制内完成。
换句话说，RTOS 强调 可预测性，而不是单纯的吞吐量。

实时操作系统应用场景：
- 汽车 ECU（发动机控制、刹车控制）
- 航空航天（飞控系统、卫星）
- 工业控制系统（机器人、数控机床）
- 医疗设备（心率监控、呼吸机）

当前较为广泛使用的 RTOS：
- VxWorks：广泛用于航空航天、防务和工业自动化领域
- RTEMS：开源，专为高性能嵌入式系统设计，常用于航空、通信和机器人领域


<hr>

每个线程都分配了从 0(最低)到 31(最高)的优先级。系统决定为 CPU 分配哪个线程时，首先检查优先级 31 的线程，并以一种轮流方式调度它们。

只要存在可调度的优先级 31 的线程，系统就永远不会将优先级 0~30 的任何线程分配给 CPU。这种情况称为饥饿。多处理器机器发生饥饿的可能性要小得多，因为这种机器上优先级为 31 的线程和优先级为 30 的线程可以同时运行。

系统启动时会创建一个特殊的零页线程。该线程的优先级是 0，而且是整个系统唯一优先级为 0 的线程。在没有其他线程需要“干活儿”的时候，零页线程将系统 RAM 的所有空闲页清零。

Microsoft 知道开发人员在为线程分配优先级时很难做到完全合理，为了解决这个问题，Windows 公开了优先级系统的一个抽象层。

设计应用程序时，要决定自己的应用程序需要比机器上同时运行的其他应用程序更大还是更小的响应能力，选择一个**进程优先级类**来反映：
- Idle
  - 在系统什么事情都不做的时候运行的应用程序(比如屏幕保护程序)适合分配 Idle 优先级类
- Below Normal
- Normal
- Above Normal
- High 
  - 只有绝对必要的时候才应使用 High 优先级类
- Realtime
  - Realtime优先级类要尽可能地避免
  - 甚至可能干扰操作系统任务，比如阻碍一些必要的磁盘 I/O 和网络传输
  - 用于需要响应延迟很短的硬件事件，或者要执行一些不能中断的“短命”任务

<hr>

优先级类和优先级是两个概念。

根据定义，每个线程的优先级取决于两个标准：
- 它的进程的优先级类
- 在其进程的优先级类中，线程的优先级

<hr>

选好优先级类之后将所有注意力放在应用程序的关系。Windows 支持 7 个相对线程优先级：
- Idle
- Lowest
- Below Normal
- Normal
- Above Normal
- Highest 
- Time-Critial

应用程序开发人员不直接操作0-31的线程优先级，而是通过设置进程优先级类 + 线程相对优先级，让系统将进程的优先级类和其中的一个线程的相对优先级映射成一个优先级(0~31)：


![2025-08-16-21-00-11.png](./images/2025-08-16-21-00-11.png)

High 优先级进程中的 Normal 线程的优先级是 13。将进程优先级类更改为 Idle，线程的优先级变成 4。

表中没有值为 0 的线程优先级。这是因为 0 优先级保留给零页线程了，系统不允许其他线程的优先级为0。

以下优先级也不可获得：17，18，19，20，21，27，28，29 或者 30。以内核模式运行的设备驱动程序才能获得这些优先级；用户模式的应用程序不能。

<p style="color:gray">注意 “进程优先级类”的概念容易引起混淆。人们可能以为 Windows 在调度进程。事实上 Windows 永远不会调度进程，它只调度线程。“进程优先级类”是 Microsoft 提出的抽象概念，旨在帮助你理解自己的应用程序和其他正在运行的应用程序的关系，它没有别的用途。</p>

最好是降低一个线程的优先级，而不是提升另一个线程的优先级。如果线程要执行长时间的计算限制任务，一般应降低该线程的优先级。如果线程要快速响应某个事件，运行短暂时间，再回复为等待状态，则应提高该线程的优先级。

高优先级线程在其生存期的大多数时间里都应出于等待状态，这样才不至于影响系统的总体响应能力。

### 26.9 前台线程和后台线程
CLR 线程分为：
- 前台线程
  - 只要有前台线程在运行，CLR 就不会让进程结束
  - 前台线程执行确实想完成的任务，比如将数据从内存缓冲区 flush 到磁盘
- 后台线程
  - 如果进程里只剩下后台线程在运行，CLR 会强制结束整个进程
  - 非关键性任务则使用后台线程，比如重新计算电子表格的单元格，或者为记录建立索引等

  
```cs
public static class Program {
    public static void Main() {
        // 创建新线程(默认为前台线程)
        Thread t = new Thread(Worker);

        // 使线程称为后台线程
        t.IsBackground = true;

        t.Start();    // 启动线程
        // 如果 t 是前台线程，则应用程序大约 10 秒后才终止
        // 如果 t 是后台线程，则应用程序立即终止
        Console.WriteLine("Returning from Main");
    }

    private static void Worker() {
        Thread.Sleep(10000);        // 模拟做 10 秒钟的工作

        // 下面这行代码只有在由一个前台线程执行时才会显示
        Console.WriteLine("Returning from Worker");
    }
}
```

在线程的生存期中，任何时候都可以从前台变成后台，或者从后台变成前台。

应用程序的主线程以及通过构造一个 Thread 对象来显式创建的任何线程都默认为前台线程。

线程池线程默认为后台线程。另外，由进入托管执行环境的本机代码创建的任何线程都被标记为后台线程。

| 类型            | 默认 IsBackground | 是否阻止进程退出 |
| ------------- | --------------- | -------- |
| ThreadPool 线程 | true            | 否        |
| Task / async  | true            | 否        |
| new Thread()  | false           | 是        |

<hr>

- 当你启动 Web API（例如 dotnet run 或 IIS/Kestrel 托管）时，宿主进程（Host）会有一个 Main 线程或者类似的主线程
- 这个主线程是 前台线程，它负责：
  - 启动 Kestrel HTTP 服务器
  - 保持 Web Host 生命周期
  - 等待进程退出信号（Ctrl+C 或 StopHost）

Web API 进程至少有一个前台线程，保证应用不会因为线程池线程都是后台线程而意外退出。

<hr>

## 27 计算限制的异步操作
计算限制操作（Compute-bound operation）就是主要消耗 CPU 资源的操作。

Compute-bound = 计算限制

“限制”是指：这个任务的执行速度受 CPU 计算能力限制。

| 操作类型     | 是否 CPU 密集 | 是否 I/O 密集 |
| -------- | --------- | --------- |
| 大数组求和    | ✅         | ❌         |
| 图像处理     | ✅         | ❌         |
| 加密运算     | ✅         | ❌         |
| 从数据库读取数据 | ❌         | ✅         |
| HTTP 请求  | ❌         | ✅         |

| 维度       | 说明                                   | 示例                                  |
| -------- | ------------------------------------ | ----------------------------------- |
| **瓶颈类型** | CPU-bound（计算限制） vs I/O-bound（I/O 限制） | CPU-bound：矩阵运算<br>I/O-bound：HTTP 请求 |
| **执行方式** | 同步 vs 异步                             | 同步：调用线程阻塞等待<br>异步：调用线程不阻塞，任务完成后通知   |


| 瓶颈类型      | 同步              | 异步                         |
| --------- | --------------- | -------------------------- |
| CPU-bound | 调用线程自己做计算，阻塞    | 放到线程池或专用线程上执行，调用线程可继续做其他事  |
| I/O-bound | 调用线程阻塞等待 I/O 完成 | 用 async/await 异步等待，调用线程不阻塞 |


### 27.1 CLR 线程池基础

NET Core/现代 .NET 取消了 AppDomain 的大部分功能，所以每个应用程序进程就是 一个 CLR 实例，线程池、垃圾回收等都是全局共享的。

前面说过线程创建和销毁代价高，所以解决方法时使用线程池。

线程池的基本概念：
- 线程池是 CLR 管理的一组可重用线程
- 线程池初始化时没有线程，只有一个任务队列

线程池的工作机制：
- 任务入队：应用程序执行异步操作时，将任务记录项加入线程池队列
- 线程分配：线程池从队列取任务，派发给空闲线程执行
  - 如果没有线程就创建，执行后线程回到线程池
  - 如果程序发出的请求速度超过线程池处理速度，就会创建新的线程
- 线程复用：完成任务后，线程回到线程池空闲等待，不立即销毁
- 动态调整：
  - 如果任务太多，线程池会创建新线程、- 如果线程闲置时间过长，会自我终止释放资源

### 27.2 执行简单的计算限制操作
**流程：QueueUserWorkItem 提交任务 → 线程池线程执行 → 回调方法运行**

要将一个异步的计算限制操作放到线程池的队列中，通常可以调用 ThreadPool 类定义的以下方法之一：
```cs
static bool QueueUserWorkItem(WaitCallback callBack);
static bool QueueUserWorkItem(WaitCallback callBack, Object state);
```
ThreadPool 是 管理 CLR 全局线程池。

```cs
public static class Program {
    public static void Main() {
        Console.WriteLine("Main thread: queuing an asynchronous operation");
        // 向线程池的队列添加一个“工作项”(work item)以及可选的状态数据
        // 可向方法传递一个 state 实参(状态数据),对应回调的Object state
        ThreadPool.QueueUserWorkItem(ComputeBoundOp, 5);
        Console.WriteLine("Main thread: Doing other work here...");
        Thread.Sleep(10000);    // 模拟其他工作(10秒)
        Console.WriteLine("Hit <Enter> to end this program...");
        Console.ReadLine();
    }

// 回调方法必须匹配 delegate void WaitCallback(Object state);

    private static void ComputeBoundOp(Object state) {
        // 这个方法由一个线程池线程执行

        Console.WriteLine("In ComputeBoundOp: state={0}", state);
        Thread.Sleep(1000);             // 模拟其他工作(1秒)

        // 这个方法返回后，线程回到池中，等待另一个任务
    }
}
```

### 27.3 执行上下文

每个线程都关联了一个执行上下文数据结构。

执行上下文包括的东西有：
- 安全设置(压缩栈、Thread 的 Principal属性和 Windows 身份)
- 宿主设置(参见 System.Threading.HostExecutionContextManager)
- 逻辑调用上下文数据(参见System.Runtime.Remoting.Messaging.CallContext 的 LogicalSetData 和 LogicalGetData方法)

线程执行它的代码时，一些操作会受到线程执行上下文设置(尤其是安全设置)的影响。理想情况下，每当一个线程(初始线程)使用另一个线程(辅助线程)执行任务时，前者的执行上下文应该流向(复制到)辅助线程。

这会对性能造成一定影响。这是因为执行上下文中包含大量信息，而收集所有这些信息，再把它们复制到辅助线程，要耗费不少时间。

System.Threading命名空间有一个 ExecutionContext 类，它允许你控制线程的执行上下文如何从一个线程“流”向另一个。

![2025-08-17-00-02-16.png](./images/2025-08-17-00-02-16.png)

可用这个类阻止执行上下文流动以提升应用程序的性能。对于服务器应用程序，性能的提升可能非常显著。但客户端应用程序的性能提升不了多少。

用Task和用ThreadPool.QueueUseWorkItem阻止执行上下文流动是一样的。

- Task.Run = 对线程池 + ExecutionContext + 异常/返回值处理的封装
- ThreadPool.QueueUserWorkItem = 直接排工作项到线程池，比较底层，功能简单


### 27.4 协作式取消和超时
Microsoft .NET 提供了标准的取消操作模式。这个模式是协作式的，意味着要取消的操作必须显式支持取消。

取消操作首先要创建一个 System.Threading.CancellationTokenSource 对象。

构造好一个 CancellationTokenSource(一个引用类型)之后，可从它的 Token 属性获得一个或多个CancellationToken(一个值类型)实例，并传给你的操作，使操作可以取消。

CancellationToken 实例是轻量级值类型，包含单个私有字段，即对其 CancellationTokenSource 对象的引用。

在计算限制操作的循环中，可定时调用 CancellationToken 的 IsCancellationRequested 属性，了解循环是否应该提前终止。

```cs
using System.Threading.Tasks;

var cts = new CancellationTokenSource();

// 多个CancellationToken实例
Task.Run(async () =>
{
    await Task.Delay(2000, cts.Token);
    Console.WriteLine("Task1 done");
}, cts.Token);

Task.Run(async () =>
{
    await Task.Delay(3000, cts.Token);
    Console.WriteLine("Task2 done");
}, cts.Token);

Thread.Sleep(1000);
cts.Cancel(); // 两个任务都会被取消
```

 要执行一个不允许被取消的操作，可向该操作传递通过调用CancellationToken.None,该属性返回一个特殊的CancellationToken实例，它不和任何CancellationTokenSource对象关联，所以没有代码能调用 Cancel。

default(CancellationToken) 与 CancellationToken.None 在语义上一样，表示“不可取消的 token”。

可调用 CancellationTokenSource 的 Register 方法登记一个或多个在取消一个 CancellationTokenSource 时调用的方法。
- 传递一个 Action\<Object\> 委托
- 传递一个Boolean值(名为useSynchronizationContext)，指明是否要使用调用线程的 SynchronizationContext 来调用委托
  - false 调用Cancel 的线程会顺序调用已登记的所有方法 （在线程池继续执行）也就是回调在 Cancel 的线程执行
  - true 回调(方法)会被 send(而不是post)给已捕捉的 SynchronizationContext 对象 （回到调用线程的 上下文） 也就是回调在捕获的上下文中执行，并且是同步（Send），所以 Cancel 会等到执行完才返回
  - ASP.NET Core 默认没有 SynchronizationContext，所以即使你传 true，也不会切回 UI/请求线程，大多数情况表现跟 false 一样

![2025-08-17-14-57-32.png](./images/2025-08-17-14-57-32.png)


一个关联其他CancellationTokenSource的demo:

![2025-08-17-14-59-05.png](./images/2025-08-17-14-59-05.png)


### 27.5 任务
用 QueueUserWorkItem 时的困境：
```cs
ThreadPool.QueueUserWorkItem(_ =>
{
    Thread.Sleep(1000);
    Console.WriteLine("工作完成");
    return 42; // <-- 这个返回值丢了，调用方拿不到
});

Console.WriteLine("主线程继续");
```

Task 就是为了解决这个问题设计的。

```cs
Task<int> t = Task.Run(() =>
{
    Thread.Sleep(1000);
    return 42;
});

int result = t.Result; // 等待任务完成并拿到返回值
Console.WriteLine($"工作完成，结果={result}");
```

QueueUserWorkItem它的回调是“fire-and-forget”（发出去就不管了），调用方没有办法 等待、取消、拿返回值，除非你自己造一堆额外的同步工具。而 Task 把这些都 内建 进来，不需要开发者重复造轮子。

```cs
ThreadPool.QueueUserWorkItem(ComputeBoundOp, 5);    // 调用 QueueUserWorkItem
new Task(ComputeBoundOp, 5).Start();                // 用 Task 来做相同的事情
Task.Run(() => ComputeBoundOp(5));                  // 另一个等价的写法
```

Task参数：
- Action 或 Action\<Object\> 委托，new Task还可传递传给操作的实参
- 调用 Run 时可以传递一个 Action 或 Func\<TResult\> 委托来指定想要执行的操作
- 可选择传递一个 CancellationToken
- 可选择向构造器传递一些 TaskCreationOptions 标志来控制 Task 的执行方式
  ```cs
  public enum TaskCreationOptions {
    None           = 0x0000,      // 默认
    
      // 提议 TaskScheduler 你希望该任务尽快执行
    PreferFairness = 0x0001,
    
      // 提议 TaskScheduler 应尽可能地创建线程池线程
    LongRunning    = 0x0002,
    
      // 该提议总是被采纳：将一个 Task 和它的父 Task 关联(稍后讨论)
    AttachedToParent = 0x0004,
    
      // 该提议总是被采纳：如果一个任务试图和这个父任务连接，它就是一个普通任务，而不是子任务
    DenyChildAttach = 0x0008,
    
      // 该提议总是被采纳：强迫子任务使用默认调度器而不是父任务的调度器
    HideScheduler = 0x0010
  }
  ```
  - 有的标志只是“提议”，TaskScheduler 在调度一个 Task 时，可能会、也可能不会采纳这些提议


```cs
using System.Threading.Tasks;

Task t = new Task(
    () => Console.WriteLine("工作中..."),
    CancellationToken.None,
    TaskCreationOptions.LongRunning | TaskCreationOptions.DenyChildAttach
);
t.Start();
```


#### 27.5.1 等待任务完成并获取结果
```cs
// 创建一个 Task(现在还没有开始运行)
Task<Int32> t = new Task<Int32>(n => Sum((Int32)n), 1000000000);

// 可以后再启动任务
t.Start();

// 可选择显式等待任务完成
t.Wait();   // 注意：还有一些重载的版本能接受 timeout/CancellationToken 值

// 可获得结果(Result 属性内部会调用 Wait)
Console.WriteLine("The Sum is: " + t.Result);   // 一个 Int32 值
```

线程调用 Wait 方法时，系统检查线程要等待的 Task 是否已开始执行
- 如果 Task 已经在运行，Wait() 会阻塞，直到 Task 完成
- 如果 Task 已经完成，Wait() 会立即返回，不阻塞
- 如果 Task 还没开始执行, 系统可能让调用 Wait() 的线程直接去执行这个 Task（内联执行）

AggregateException 类型封装了异常对象的一个集合。当 父任务有多个子任务抛出异常 时，异常会被封装成一个 AggregateException 对象。
- InnerExceptions 属性：返回所有子异常的只读集合
- InnerException属性：是AggregateException 类从 System.Exception 基类继承的，只返回第一个异常
- 提供辅助方法：
  - Flatten()：把嵌套的 AggregateException 展平成一个平坦的集合
  - Handle(Func\<Exception, bool\>)：为每个异常调用回调方法，返回 true 表示处理完成，否则重新抛出未处理的异常
  - GetBaseException()：返回最底层的根本异常

Task 异常观察
- 如果不调用 Wait() / Result / Exception，Task 异常可能被忽略
- 为了捕获未观察到的异常，可以注册 TaskScheduler.UnobservedTaskException 事件
- 当 Task 被垃圾回收且异常未被观察时，会触发该事件，传入 UnobservedTaskExceptionEventArgs，包含异常对象

等待 Task
- 单个 Task：调用 Wait() 或读取 Result，线程会阻塞直到 Task 完成
- 多个 Task：提供两个静态方法：
  - WaitAny(Task[] tasks, …)：阻塞直到任意一个 Task 完成，返回完成的 Task 索引
  - WaitAll(Task[] tasks, …)：阻塞直到所有 Task 完成，返回 true/false 表示是否完成

<p style="color:grey">调用Wait()和在Task前面加await是不一样的，当遇到 await 时，如果任务还没完成，当前方法会“挂起”，把控制权还给调用方，线程不会阻塞，可以继续执行其他任务。</p>

#### 27.5.2 取消任务
看前面的demo，就是把CancellationToken传给Task

#### 27.5.3 任务完成时自动启动新任务
伸缩性好的软件不应该使线程阻塞。调用 Wait，或者在任务尚未完成时查询任务的 Result 属性，极有可能造成线程池创建新线程，这增大了资源的消耗，也不利于性能和伸缩性。

更好的办法可以知道一个任务在什么时候结束运行。任务完成时可启动另一个任务。

![2025-08-23-20-35-14.png](./images/2025-08-23-20-35-14.png)

上面的代码当前线程不会阻塞，但委托默认可能在线程池线程里运行（不是当前上下文），所以也不想await，更像是事件回调。

执行 Sum 的任务完成时会启动另一个任务(也在某个线程池线程上)以显示结果。

Task 对象内部包含了 ContinueWith 任务的一个集合。所以，实际可以用一个 Task 对象来多次调用 ContinueWith。任务完成时，所有ContinueWith 任务都会进入线程池的队列中。

可在调用 ContinueWith 时传递对一组 TaskContinuationOptions 枚举值进行按位 OR 运算的结果。前 6 个标志(None，PreferFairness，LongRunning，AttachedToParent，DenyChildAttach 和 HideScheduler)与之前描述的 TaskCreationOptions 枚举类型提供的标志完全一致。

默认情况下，如果不指定上述任何标志，则新任务无论如何都会运行，不管第一个任务如何完成。一个 Task 完成时，它的所有未运行的延续任务都被自动取消。

![2025-08-23-20-51-01.png](./images/2025-08-23-20-51-01.png)

#### 27.5.4 任务可以启动子任务

![2025-08-23-21-36-35.png](./images/2025-08-23-21-36-35.png)


这里的 parent 只是一个 还没启动的 Task。

只有当对 parent 调用 Start() 或者 parent.RunSynchronously() 的时候，里面的委托才会被执行。而“里面的委托”负责 创建并启动子任务。也就是说：子任务的创建和启动逻辑根本没有机会运行，因为父任务还没跑。

#### 27.5.5 任务内部揭秘
Task 对象的组成,每个 Task 内部维护一堆字段:
- ID（首次访问 Id 属性时分配，调试器里用来区分任务）
- 状态（TaskStatus 枚举）
- 父任务的引用（支持附加子任务）
- TaskScheduler 的引用（控制如何调度执行）
- 回调方法和参数（即要执行的委托与 AsyncState）
- ExecutionContext（捕获调用线程的执行上下文）
- ManualResetEventSlim（用于 Wait() 等场景阻塞等待）
- 补充状态（例如 CancellationToken、continuation 集合、异常集合等）


Task 的生命周期,Status属性返回一个TaskStatus:
- WaitingForActivation → 框架创建的，等内部触发（例如 ContinueWith）。
- WaitingToRun → 已经调度，等线程池分配线程。
- Running → 正在执行。
- WaitingForChildrenToComplete → 本身完成了，但要等子任务结束。
- 结束态（3 种之一）：
  - RanToCompletion
  - Canceled
  - Faulted

ContinueWith(...) 创建的新任务一开始是 WaitingForActivation 状态。

Task 和 Task\<TResult\> 实现了 IDisposable，但默认只用来清理内部的 ManualResetEventSlim。

一般不需要手动调用 Dispose()，让 GC 自己清理就好。

除非派生自 Task 并分配了额外资源，那才需要显式释放。

如果只需要最轻量级的后台执行，可以直接用 ThreadPool.QueueUserWorkItem，开销更小。但绝大多数业务场景，还是推荐用 Task，因为它和 async/await、异常处理等更好集成。

#### 27.5.6 任务工厂
有时需要创建一组共享相同配置的 Task 对象。为避免机械地将相同的参数传给每个 Task 的构造器。可使用TaskFactory 和 TaskFactory\<TResult\> 类型。

```cs
Task parent = new Task(() => {
    var cts = new CancellationTokenSource();
    var tf = new TaskFactory<Int32>(cts.Token,
        TaskCreationOptions.AttachedToParent,
        TaskContinuationOptions.ExecuteSynchronously,
        TaskScheduler.Default);

    // 这个任务创建并启动 3 个子任务
    var childTasks = new[] {
        tf.StartNew(() => Sum(10000)),
        tf.StartNew(()=> Sum(20000)),
        tf.StartNew(()=> Sum(Int32.MaxValue)) // 太大，抛出 OverflowException
    };

    // 任何子任务抛出异常，就取消其余子任务
    for (Int32 task = 0; task < childTasks.Length; task++)
        childTasks[task].ContinueWith(
            t => cts.Cancel(), TaskContinuationOptions.OnlyOnFaulted);

    // 所有子任务完成后，从未出错/未取消的任务获取返回的最大值，
    // 然后将最大值传给另一个任务来显示最大结果
    tf.ContinueWhenAll(
        childTasks,
        completedTasks => completedTasks.Where(t => !t.IsFaulted && !t.IsCanceled).Max(t => t.Result),
        CancellationToken.None)
            .ContinueWith(t => Console.WriteLine("The maximum is: " + t.Result),
                TaskContinuationOptions.ExecuteSynchronously);                        
});

// 启动父任务，使它能启动子任务
parent.Start();
```

#### 27.5.7 任务调度器
Task 的灵活性主要来自于 TaskScheduler，它决定了“任务在哪里、怎样跑”。

FCL提供两个派生自TaskScheduler的类型：
- 线程池任务调度器 (Thread Pool Task Scheduler) web api默认用的
  - 默认的调度器：TaskScheduler.Default
  - 所有 Task.Run()、Task.Factory.StartNew() 默认都走这个
  - 本质就是把任务放到 CLR 线程池，线程池会动态分配工作线程去跑。
- 同步上下文任务调度器 (Synchronization Context Task Scheduler)
  - 通过 TaskScheduler.FromCurrentSynchronizationContext() 获取
  - 常用于 UI 应用（WinForms、WPF、UWP）
  - 不是线程池线程，而是把任务排到 UI 消息循环里
    - 在 Windows GUI 程序（WinForms、WPF 等）里，只有一个主线程负责绘制界面、响应用户事件。
    - 这个线程运行着一个 消息循环，不断取出消息（鼠标点击、键盘输入、重绘事件等），然后调用对应的回调
    - 所有控件（按钮、文本框等）的更新，都必须在这个 UI 线程里执行
  - UI 同步上下文调度器是怎么做
    - 当用 TaskScheduler.FromCurrentSynchronizationContext() 获取 UI 调度器时
      - continuation 不会去线程池，而是被放入 UI 消息循环里作为一个消息
      - 消息循环最终会在 UI 线程 上取出消息，执行 continuation 的代码
      - 这样保证了 UI 更新总是在正确的线程里运行

错误示例（跨线程更新 UI，抛异常）
```cs
Task.Run(() =>
{
    button.Text = "更新"; // 在后台线程，直接操作 UI 控件会抛异常
});
```

正确示例（回到 UI 消息循环）
```cs
var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();

Task.Run(() =>
{
    return "更新成功";
})
.ContinueWith(t =>
{
    button.Text = t.Result; // 在 UI 线程执行，可以安全修改控件
}, uiScheduler);
```

这里 ContinueWith 的第二个参数 uiScheduler 就是 同步上下文任务调度器，它会把 continuation 任务排到 UI 消息循环中，所以最终由 UI 线程来运行。

### Parallel 的静态 For，ForEach 和 Invoke方法
一些常见的编程情形可通过任务提升性能。

```cs
// 一个线程顺序执行这个工作(每次迭代调用一次 DoWork)
for (Int32 i = 0; i < 1000; i++) DoWork(i);

// 线程池的线程并行处理工作
Parallel.For(0, 1000, i => DoWork(i));

// 一个线程顺序执行这个工作(每次迭代调用一次 DoWork)
foreach (var item in collection) DoWork(item);

// 线程池的线程并行处理工作
Parallel.ForEach(collection, item => DoWork(item));
```

**如果既可以使用 For， 也可以使用 ForEach， 那么建议使用 For，因为它执行得更快。**

Parallel.For 或 Parallel.ForEach每个迭代都是独立任务，如果某个迭代抛异常,其他迭代仍然继续执行，不会被立刻中断,但所有异常会被收集，在 Parallel 退出时统一抛出 AggregateException。

调用 Parallel 的方法时有一个很重要的前提条件：
- 工作项必须能并行执行
- 要避免会修改任何共享数据的工作项，否则多个线程同时处理可能会损坏数据，解决这个问题一般的办法是围绕数据访问添加线程同步锁，这样也无法享受并行带来的好处，所以还不如不用

Parallel 的方法本身也有开销；委托对象必须分配，而针对每个工作项都要调用一次这些委托。如果有大量可由多个线程处理的工作项，那么也许能获得性能的提升。另外，如果每一项都涉及大量工作，那么通过委托来调用所产生的性能损失是可以忽略不计的。但如果只为区区几个工作项使用 Parallel 的方法，或者为处理得非常快的工作项使用 Parallel 的方法，就会得不偿失，反而降低性能。

<hr>

**下面的知识点非常重要！！！**
一个是否选择Parallel的方法：
- CPU 密集 → Parallel 并行
- IO 密集 → async/await 异步并发

Parallel 的执行方式
- Parallel.For / Parallel.ForEach 会把迭代任务分发到 线程池线程
- 默认情况下，线程数大约 = CPU 核心数 × 1~2
- 每个迭代占用一个线程直到完成（阻塞线程）
- 所以适合 CPU 密集型任务，因为希望多个核心同时做计算

IO 密集型任务的问题
- IO 操作（HTTP 请求、数据库访问）大部分时间是 等待
- 如果用 Parallel：
  - 每个迭代都阻塞线程等待 IO 完成
  - 线程池线程被占用 → 其他任务排队
  - 并行化带来的 CPU 利用率提升非常小

IO 密集 可以使用Task.WhenAll
- Task.WhenAll 发起的是 异步任务（非阻塞线程）
- 同时可以创建成百上千个异步任务，但线程不会被阻塞
- CPU 核心只在处理回调和结果计算时才占用

Parallel本身就可以限制同时运行的线程，而对异步 Task，可以用 信号量 限制同时执行数量：
```cs
SemaphoreSlim sem = new SemaphoreSlim(4); // 同时最多 4 个任务
var tasks = urls.Select(async url =>
{
    await sem.WaitAsync();
    try
    {
        await httpClient.GetStringAsync(url);
    }
    finally
    {
        sem.Release();
    }
});
await Task.WhenAll(tasks);
```

<hr>

### 27.7 并行语言集成查询(PLINQ)
顺序 LINQ vs 并行 LINQ
- 顺序 LINQ：使用 IEnumerable 遍历数据，单线程顺序处理数据项
- 并行 LINQ（PLINQ）：使用 ParallelEnumerable 类，将数据项分发到多个线程并行处理，从而加速 CPU 密集型任务

- AsParallel() 将顺序查询转换成并行查询
- AsSequential() 从执行并行操作切换回执行顺序操作
- ForAll() 多个线程同时处理结果
  - 若执行涉及线程不安全操作（如 Console.WriteLine），可能损害性能
- AsOrdered() 让 PLINQ 保持数据项的顺序 
  - 调用这个方法时，线程会成组处理数据项。然后，这些组被合并回去，同时保持顺序。这样会损害性能
  - 以下操作符生成不排序的操作：Distinct，Except，Intersect，Union，Join，GroupBy，GroupJoin 和 ToLookup
  - 在这些操作符之后要再次强制排序，只需调用AsOrdered 方法
  - 要再次恢复不排序的处理，只需调用 AsUnordered 方法

```cs
void Main()
{
        // 准备数据
        int[] numbers = Enumerable.Range(1, 20).ToArray();

        Console.WriteLine("===== 顺序 LINQ =====");
        var sequentialQuery = numbers
            .Where(x => x > 10)
            .Select(x => x * x);

        foreach (var item in sequentialQuery)
        {
            Console.WriteLine($"Thread {Thread.CurrentThread.ManagedThreadId} - {item}");
        }

        Console.WriteLine("\n===== 并行 PLINQ =====");
        var parallelQuery = numbers.AsParallel()
                                   .Where(x => x > 10)
                                   .Select(x => x * x);

        // 注意：foreach 默认顺序遍历结果（顺序处理），计算已经并行
        foreach (var item in parallelQuery)
        {
            Console.WriteLine($"Thread {Thread.CurrentThread.ManagedThreadId} - {item}");
        }

        Console.WriteLine("\n===== PLINQ ForAll 并行处理结果 =====");
        // ForAll 允许多个线程同时处理结果
        parallelQuery.ForAll(item =>
        {
            Console.WriteLine($"Thread {Thread.CurrentThread.ManagedThreadId} - {item}");
        });

        Console.WriteLine("\n===== PLINQ 保持顺序 AsOrdered =====");
        var orderedQuery = numbers.AsParallel()
                                  .AsOrdered()       // 保持顺序
                                  .Where(x => x > 10)
                                  .Select(x => x * x);

        orderedQuery.ForAll(item =>
        {
            Console.WriteLine($"Thread {Thread.CurrentThread.ManagedThreadId} - {item}");
        });

        Console.WriteLine("\n===== PLINQ 控制并行度 WithDegreeOfParallelism(2) =====");
        var limitedParallel = numbers.AsParallel()
                                     .WithDegreeOfParallelism(2)
                                     .Where(x => x > 10)
                                     .Select(x => x * x);

        limitedParallel.ForAll(item =>
        {
            Console.WriteLine($"Thread {Thread.CurrentThread.ManagedThreadId} - {item}");
        });

        Console.WriteLine("\n===== 演示结束 =====");
}
```

![2025-08-23-23-55-12.png](./images/2025-08-23-23-55-12.png)

PLINQ 提供多个扩展方法控制执行方式：
| 方法                                         | 功能                                               |
| ------------------------------------------ | ------------------------------------------------ |
| `WithCancellation(CancellationToken)`      | 支持提前取消查询                                         |
| `WithDegreeOfParallelism(int)`             | 限制最大并行线程数（一般不超过 CPU 核心数）                         |
| `WithExecutionMode(ParallelExecutionMode)` | 强制并行或让系统选择（Default/ForceParallelism）             |
| `WithMergeOptions(ParallelMergeOptions)`   | 控制结果缓冲策略（NotBuffered/AutoBuffered/FullyBuffered） |


适用场景：处理大量数据项且每项操作耗时明显（CPU 密集型任务），并行能获得显著性能提升

不适用场景：
- 数据项少或操作非常快 → 并行开销可能抵消收益
- 包含同步 I/O 操作 → 线程被阻塞，影响性能

<hr>

```cs
var query = collection.AsParallel()
                      .Where(x => x > 10)
                      .Select(x => x * x);
```

PLINQ 会做以下事情：
- 数据分块
  - 假设 CPU 有 4 核心，集合有 1000 个元素
  - PLINQ 会把集合分成 4 份，每份大约 250 个元素
  - 每块数据独立处理，不依赖其他块
- 分配线程（线程池）
  - 每个数据块被分配到 线程池线程，多个块可以同时处理
  - 线程池线程并行执行 Where 和 Select 里的逻辑
- 合并结果
  - 每个线程得到自己块的查询结果
  - PLINQ 最终将结果合并成一个 ParallelQuery 对象
  - 默认是无序合并，如果调用 AsOrdered() 会保持原顺序，但可能牺牲一点性能


<hr>

### 27.8 执行定时的计算限制操作
System.Threading 命名空间定义了一个 Timer 类，可用它让一个线程池线程定时调用一个方法。

Timer定义：
```cs
public sealed class Timer : MarshalByRefObject, IDisposable {
    public Timer(TimerCallback callback, Object state, Int32    dueTime, Int32 period);
    public Timer(TimerCallback callback, Object state, UInt32   dueTime, UInt32 period);
    public Timer(TimerCallback callback, Object state, Int64    dueTime, Int64 period);
    public Timer(TimerCallback callback, Object state, TimeSpan dueTime, TimeSpan period)
}
```

- 写的回调方法必须和System.Threading.TimerCallback 委托类型匹配 `delegate void TimerCallback(Object state);`
- state 参数允许在每次调用回调方法时都向它传递状态数据
- dueTime参数告诉CLR 在首次调用回调方法之前要等待多少毫秒
- period指定了以后每次调用回调方法之前要等多少毫秒。如果为这个参数传递 Timeout.Infinite(-1)，线程池线程只调用回调方法一次

在内部，线程池为所有 Timer 对象只使用了一个线程。这个线程知道下一个 Timer 对象在什么时候到期(计时器还有多久触发)。下一个 Timer 对象到期时，线程就会唤醒，在内部调用 ThreadPool 的 QueueUserWorkItem， 将一个工作项添加到线程池的队列中，使回调方法得到调用。

如果回调方法的执行时间很长，计时器可能(在上个回调还没有完成的时候)再次触发。这可能造成多个线程池线程同时执行这个回调方法，解决方法是：构造 Timer 时，为 period 参数指定 Timeout.Infinite。这样，计时器就只触发一次。然后，在回调方法中，调用 Change 方法来指定一个新的 dueTime，并再次为 period 参数指定 Timeout.Infinite

```cs
using System;
using System.Threading;

class TimerDemo
{
    // 保持 Timer 引用，防止被垃圾回收
    private static Timer _timer;

    static void Main()
    {
        Console.WriteLine("Timer demo: 每 2 秒执行一次任务，避免重叠\n");

        // 创建 Timer，但暂不启动
        _timer = new Timer(TimerCallbackMethod, null, Timeout.Infinite, Timeout.Infinite);

        // 启动 Timer，首次立即执行
        _timer.Change(0, Timeout.Infinite);

        Console.WriteLine("按回车退出...");
        Console.ReadLine();

        // 停止并释放 Timer
        _timer.Dispose();
    }

    private static void TimerCallbackMethod(object state)
    {
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] 开始执行回调，线程ID: {Thread.CurrentThread.ManagedThreadId}");

        // 模拟耗时操作
        Thread.Sleep(1500);  // 1.5 秒

        Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] 回调完成，线程ID: {Thread.CurrentThread.ManagedThreadId}");

        // 2 秒后再次触发 Timer（避免回调重叠）
        _timer.Change(2000, Timeout.Infinite);
    }
}

```

![2025-08-24-00-22-05.png](./images/2025-08-24-00-22-05.png)

Timer 对象被垃圾回收时，它的终结代码告诉线程池取消计时器，使它不再触发。所以，使用 Timer 对象时，要确定有一个变量在保持 Timer 对象的存活，否则对你的回调方法的调用就会停止。

<hr>

问题：对于一个服务器，CPU一般很少吧，但一般一个服务器有很多应用程序，线程数远远大于CPU数

线程数远大于 CPU 核心数是正常的，特别是服务器环境
关键是任务类型：
- CPU 密集 → 控制线程数
- IO 密集 → 可以多线程或异步
程池和操作系统调度机制可以让少量 CPU 核心高效处理大量并发请求

总结：CPU密集就是长时间运行的任务，所以需要控制线程数约等于线程数，因为实际运行就是CPU核心数，只是通过时间轮片调度多个线程的，如果是长时间任务过多线程就会减低效率。

<hr>

##  28  I/O 限制的异步操作


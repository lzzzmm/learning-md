# 0-asp.net core-中间件基础
## 1、request到response的历程
![2024-10-17-13-20-39.png](./images/2024-10-17-13-20-39.png)

EndPoint（终结点）中间件一般为相应的应用类型，比如MVC。

![2024-10-17-13-57-55.png](./images/2024-10-17-13-57-55.png)

中间件是ASP.NET CORE提供的功能，而Filter是ASP.NET CORE MVC提供的功能。

中间件是一种装配到应用管道以处理请求和响应的软件。 每个组件：
- 选择是否将请求传递到管道中的下一个组件
- 可在管道中的下一个组件前后执行工作

## 2、中间件管道
### 2.1 Run
该方法为HTTP请求管道添加一个中间件，并标识该中间件为管道终点，称为终端中间件。也就是说，该中间件就是管道的末尾，在该中间件之后注册的中间件将永远都不会被执行。这是单个请求委托。

将这个方法放在第一个注册的位置，然后执行项目，可以看到出现的不是swagger页面而是hello world。
```cs
app.Run(async context =>
{
    Console.WriteLine("hello world");
    await context.Response.WriteAsync("Hello world!");
});
```
![2024-10-18-09-44-14.png](./images/2024-10-18-09-44-14.png)


### 2.2 Use
需要多个委托执行中间件执行前后的逻辑的话，就使用Use。可以按过滤器的逻辑理解。

![2024-10-18-09-55-13.png](./images/2024-10-18-09-55-13.png)

next 参数表示管道中的下一个委托。 可通过不调用 next 参数使管道短路。 通常可在 next 委托前后执行操作。

```cs
app.Use(async (context, next) =>
{
    Console.WriteLine("hello world1");
    await next.Invoke();
    Console.WriteLine("Hello world2!");
});
```

- 如果要将请求发送到管道中的下一个中间件，一定要记得调用next.Invoke / next()
- 如果已经开始给客户端发送Response，请千万不要调用next.Invoke / next()，也不要对Response进行任何更改，否则，将抛出异常
- 可以通过context.Response.HasStarted来判断响应是否已开始

```cs
app.Use(async (context, next) =>
{
    Console.WriteLine("hello world1");
    await context.Response.WriteAsync("Hello world!");
    await next.Invoke();
    Console.WriteLine("Hello world2!");
});
```
上面这样写是错误的，会报错。

![2024-10-18-09-57-41.png](./images/2024-10-18-09-57-41.png)

### 2.3 UseWhen
针对不同的逻辑条件创建管道分支。需要注意的是:
- 进入了管道分支后，如果管道分支不存在管道短路或终端中间件，则会再次返回到主管道
- 使用PathString时，路径必须以“/”开头，且允许只有一个'/'字符
- 支持UseWhen中嵌套UseWhen
- 支持同时匹配多个段


### 2.4 Map
针对不同的请求路径创建管道分支：
- 一旦进入了管道分支，则不会再回到主管道
- 使用该方法时，会将匹配的路径从HttpRequest.Path 中删除，并将其追加到HttpRequest.PathBase中
- 路径必须以“/”开头，且不能只有一个'/'字符
- 支持嵌套，即Map中嵌套Map、MapWhen
- 支持同时匹配多个段


### 2.5 MapWhen
与Map类似，MapWhen是基于逻辑条件创建管道分支：
- 一旦进入了管道分支，则不会再回到主管道
- 当使用PathString时，路径必须以“/”开头，且允许只有一个'/'字符
- HttpRequest.Path和HttpRequest.PathBase不会像Map那样进行特别处理
- 支持嵌套
- 支持同时匹配多个段

### 2.6 总结
- Run用于注册终端中间件，Use用来注册匿名中间件，UseWhen、Map、MapWhen用于创建管道分支
- UseWhen进入管道分支后，如果管道分支中不存在短路或终端中间件，则会返回到主管道。Map和MapWhen进入管道分支后，无论如何，都不会再返回到主管道
- UseWhen和MapWhen基于逻辑条件来创建管道分支，而Map基于请求路径来创建管道分支，且会对HttpRequest.Path和HttpRequest.PathBase进行处理


## 3、常用内置中间件
微软文档建议顺序：
```cs
if (app.Environment.IsDevelopment())
{
    app.UseMigrationsEndPoint();
}
else
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();
// app.UseCookiePolicy();

app.UseRouting();
// app.UseRateLimiter();
// app.UseRequestLocalization();
// app.UseCors();

app.UseAuthentication();
app.UseAuthorization();
// app.UseSession();
// app.UseResponseCompression();
// app.UseResponseCaching();
```
不是一定是这个顺序，但有些顺序是固定的：
- UseCors、UseAuthentication 和 UseAuthorization 必须按显示的顺序出现。
- UseCors 当前必须在 UseResponseCaching 之前出现
- UseRequestLocalization 必须在可能检查请求区域性的任何中间件（例如 app.UseStaticFiles()）之前出现。
### 3.1 异常处理中间件
分为两种，在开发环境中使用 UseDeveloperExceptionPage 生产环境使用UseExceptionHandler。

使用顺序是在生成错误的组件之前。异常终端或为新应用提供默认网页的终端。
#### 3.1.1 UseDeveloperExceptionPage 


#### 3.1.2 UseExceptionHandler 

### 3.2 HTTPS重定向中间件
HTTPS重定向中间件（ UseHttpsRedirection ）能将HTTP请求重定向到HTTPS，非HTTPS的站点配置非常的方便。


### 3.3 静态文件中间件
静态文件中间件（ UseStaticFiles ）返回静态文件，为提供静态文件和目录浏览提供支持。

### 3.4 Cookie中间件
Cookie策略中间件（ UseCookiePolicy ）。跟踪用户是否同意存储个人信息，并强制实施 cookie 字段（如 secure 和 SameSite）的最低标准。使用顺序是在发出 cookie 的中间件之前。示例：身份验证、会话、MVC (TempData)。

### 3.5 路由中间件
路由中间件（ UseRouting ）用于定义和约束请求路由。

### 3.6 身份认证中间件
执行顺序需要在 HttpContext.User 之前， OAuth 回叫的终端。

### 3.7 授权中间件
执行顺序需要在 HttpContext.User 之前， OAuth 回叫的终端。

### 3.8 会话中间件
会话中间件（ UseSession ）提供对管理用户会话的支持。应用程序使用会话状态，需要在Cookie策略中间件之后和MVC中间件之前调用会话中间件。

### 3.9 终结点路由中间件
终结点路由中间件（ UseEndpoints ）向中间件管道添加终结点执行。实际路径执行的。可以配置我们的默认路由等。注意UseEndpoints 跟UseRouting的区别。

### 3.10 跨域请求中间件
跨域请求中间件（UseCors）可以配置跨域的网站，跨域请求策略可防止恶意站点从另一站点读取敏感数据。使用顺序是 UseCors 的调用必须放在 UseRouting 之后，但在 UseAuthorization 之前。

就是匹配域名白名单，只有在白名单内的域名才能访问站点接口。

## 4、自定义中间件
